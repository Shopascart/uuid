
/**
 * The `randomBytes` function generates a random array of bytes and provides a method to convert it to
 * a hexadecimal string.
 * @param {number} size - The `size` parameter in the `randomBytes` function represents the number of
 * random bytes you want to generate. It specifies the length of the `Uint8Array` that will hold the
 * random bytes.
 * @returns The function `randomBytes` returns an object with two properties: `value` and `toString`.
 * The `value` property is of type `Uint8Array` and contains the randomly generated bytes. The
 * `toString` property is a function that takes a single argument `type` of type `"hex"`. It converts
 * the bytes to a string representation based on the `type` argument. If the `type` argument is `"hex"`,
 * it converts the bytes to a hexadecimal string. If the `type` argument is `"string"`, it converts the
 * bytes to a string.
 */
export const randomBytes = (size: number): {
    value: Uint8Array
    toString: (type: "hex") => string
} => {
    const randomBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        randomBytes[i] = Math.floor(Math.random() * 256);
    }
    const toString = (type: "hex") => {
        let res = '';
        if (type === "hex") {
            const len = randomBytes.length;
            for (let i = 0; i < len; i++) {
                res += (randomBytes[i] < 16 ? '0' : '') + randomBytes[i].toString(16);
            }
        } else {
            const len = randomBytes.length;
            for (let i = 0; i < len; i++) {
                res += String.fromCharCode(randomBytes[i]);
            }
        }
        return res;
    }
    return {
        value: randomBytes,
        toString: toString
    }
}


export const RandomBits = (size: number): Uint8Array => {
    return randomBytes(size).value;
}

/**
* Generate a random hex string
* @param size - The size of the random hex string to be generated
* @returns A random hex string
*/
export const HexRandomBytes = (size: number): string => {
    return randomBytes(size).toString('hex');
}


export interface IUniqueID {
    /**
     * Prefix to be added to the unique ID
    */
    prefix?: string;
    /**
     * The type of unique ID to be generated. It can be either "string" or "number"
     * @default "string"    
     * */
    type?: "string" | "number";
    /**
     * Generate a unique ID
     * @param {number} length - The length of the unique ID to be generated
     * @returns {string | number} - A unique ID
     */
    generate(length?: number): IUniqueID['type'] extends "string" ? string : number
    generate(length?: number): IUniqueID['type'] extends "number" ? number : string
    generate(length?: number): string | number;
    /**
     * A method that tests the accuracy of the unique ID algorithm
     * @returns {boolean} A boolean value that indicates whether the unique ID algorithm is accurate
     * @example
     * const uniqueID = new UniqueID();
     * const status = uniqueID.testUniqueID(); // true
     **/
    testUniqueID(): boolean;
    /**
     * The `runUUID` function generates a large number of unique IDs and checks for duplicates. It also
     * measures the time taken to generate the unique IDs.
     * @param - An object that contains the length of the unique ID to be generated and the number of unique IDs to be generated.
     * If the `idsLength` property is not provided, it defaults to 100000.
     */
    runUUID({ length, idsLength }: { length?: number, idsLength?: number }): void
}

/**
 * The UniqueID class provides a set of methods for generating and testing unique IDs. It can be used to generate unique IDs of type string or number and can also be used to test the accuracy of the unique ID algorithm
 * @description A class that generates unique IDs
 * @param {string} prefix - A prefix to be added to the unique ID
 * @param {string} type - The type of unique ID to be generated. It can be either "string" or "number"
 * @returns {string | number} - A unique ID
 * @example
 * const uniqueID = new UniqueID(prefix, type) // prefix_a12dkqwe14972
 */

export class UniqueID implements IUniqueID {
    readonly prefix: string;
    readonly type: "string" | "number";
    private ALPHANUMERIC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    constructor(prefix?: string, type?: "string" | "number") {
        this.prefix = prefix ? prefix : "";
        this.type = type ? type : "string";
    }
    generate(length?: number): IUniqueID['type'] extends "string" ? string : number
    generate(length?: number): IUniqueID['type'] extends "number" ? number : string
    public generate(length?: number): string | number {
        const rnd = RandomBits(1)[0];
        const timestamp = new Date().getTime();
        const val = new Array(length ? length : 24);
        const charsLength = this.ALPHANUMERIC.length;
        const randomNum = Math.floor((Math.random() * 100000000) * 0x100000000);
        const uuid = HexRandomBytes(16);
        for (let i = 0; i < val.length; i++) {
            val[i] = this.ALPHANUMERIC.charAt(Math.floor(Math.random() * charsLength));
        }
        if (this.type === "string") {
            const unique = this.prefix ? `${this.prefix}_${uuid}${timestamp}${randomNum}${rnd}` : `${uuid}${timestamp}${randomNum}${rnd}`;
            const uniqueID = unique.substring(0, length ? length : 16);
            return uniqueID as string;
        } else {
            const r = Math.floor(Math.random() * 1000000000);
            const result = `${r}${timestamp}${randomNum}${rnd}`;
            const uniqueID = Number(result.substring(0, length));
            return uniqueID as number;
        }
    }

    // generateV4<Prefix extends string ="-">({ prefix, type }: { prefix: Prefix, type: "random" }): `${string}${Prefix}${string}${Prefix}${string}${Prefix}${string}`
    // generateV4<Prefix extends string ="-">({ prefix, type }: { prefix: Prefix, type: "string" }): `${string}${Prefix}${string}${Prefix}${string}${Prefix}${string}`
    // generateV4<Prefix extends string ="-">({ prefix, type }: { prefix: Prefix, type: "number" }): `${number}${Prefix}${number}${Prefix}${number}${Prefix}${number}`
    // generateV4({ type}: { type: "random" }): `${string}_${string}_${string}_${string}`;
    // generateV4({ type}: { type: "string" }): `${string}_${string}_${string}_${string}`;
    // generateV4({ type}: { type: "number" }): `${number}_${number}_${number}_${number}`;
    // generateV4(): `${string}_${string}_${string}_${string}`;
    // generateV4({}: {}): `${string}_${string}_${string}_${string}`;

    // public generateV4<Prefix extends string ="-", Type extends "random" | "string" | "number" = "random">(options?: { prefix?: Prefix, type?: Type, length?: number }): `${string}${Prefix}${string}${Prefix}${string}${Prefix}${string}` | `${number}${Prefix}${number}${Prefix}${number}${Prefix}${number}` {

    // }
    public testUniqueID(): boolean {
        const ids = new Set<string | number>();
        const length = 100000;
        for (let i = 0; i < length; i++) {
            const id = this.generate();
            if (ids.has(id)) {
                return false;
            }
            ids.add(id);
        }
        return true;
    }

    private checkUniqueIDDuplicates(array: Array<number | string>, getCases?: boolean): {
        status: boolean,
        cases?: Array<string>,
        duplicates?: Array<number | string>
    } {
        const cases = [];
        const duplicates = [];
        if (getCases) {
            for (let i = 0; i < array.length; i++) {
                const element = array[i];
                const index = array.indexOf(element);
                if (index !== i) {
                    cases.push(`Case ${i} and ${index} are duplicates`);
                }
            }
        }
        let sorted_arr = array.slice().sort();
        for (let i = 0; i < sorted_arr.length - 1; i++) {
            if (sorted_arr[i + 1] == sorted_arr[i]) {
                duplicates.push(sorted_arr[i]);
            }
        }
        if (duplicates.length === 0) {
            return {
                status: false,
                cases: cases,
                duplicates: duplicates
            }
        } else {
            return {
                status: true,
                cases: cases,
                duplicates: duplicates
            }
        }
    }

    private duplicates(array: Array<number | string>): {
        status: boolean,
        cases?: Array<string>,
        duplicates?: Array<number | string>
    } {
        return this.checkUniqueIDDuplicates(array, true);
    }

    public runUUID({ length, idsLength }: { length?: number, idsLength?: number } = {}): void {
        const uniqueID = new UniqueID(this.prefix, this.type);
        const ids = new Set<string | number>();
        const start = new Date().getTime();
        const len = idsLength ? idsLength : 100000;
        console.log("Start time: ", `${start}ms`);
        for (let i = 0; i < len; i++) {
            const id = uniqueID.generate(length ?? 24);
            if (ids.has(id)) {
                console.log("Duplicate: ", id);
                break;
            }
            ids.add(id);
        }
        const end = new Date().getTime();
        console.log("End time: ", `${end}ms`);
        console.log("Time taken: ", `${(end - start)}ms`);
        console.log("Number of unique IDs generated: ", ids.size);
    }
}



export type TUUIDOptions<Prefix extends string> = {
    // So it has been discoverd that the type number is not unique when generating a large number of unique IDs so it is recommended to use the type string for now
    /**
     * The type of unique ID to be generated. It can be either "string" or "number"
     * **Note**: The type number is not unique when generating a large number of unique IDs so it is recommended to use the type string for now 
     * */
    type?: "string" | "number",
    /**
     * Prefix to be added to the unique ID
    */
    prefix?: Prefix,
    /**
     * The length of the unique ID to be generated. It defaults to 24
     */
    length?: number
}


type TString<Prefix extends string> = {
    /**
        * Generates a unique ID
        * @returns {string} - A unique ID with the specified prefix and length
    */
    generate(): `${Prefix}_${string}`,
    /**
        * The test method can be used to test the uniqueness of the unique ID algorithm by generating a large number of unique IDs and checking for duplicates
        * @returns {boolean} A boolean that indicates whether the list of generated unique IDs are unique or not
    */
    test(): boolean,
    /**
     * The `runUUID` function generates a large number of unique IDs and checks for duplicates. It also
     * measures the time taken to generate the unique IDs.
     * @param - `idsLength` an optional parameter which specifies the number of
     * unique IDs to generate. If `idsLength` is not provided, it defaults to 100000.
     */
    runUUID(idsLength?: number): void
}
type TNumber = {
    /**
       * Generates a unique ID
       * @returns {number} - A unique ID with the specified length
   */
    generate(): number,
    /**
       * The test method tests the uniqueness of the unique ID algorithm by generating a large number of unique IDs and checking for duplicates
       * @returns {boolean} A boolean that indicates whether the list of generated unique IDs are unique or not
   */
    test(): boolean,
    /**
    * The `runUUID` function generates a large number of unique IDs and checks for duplicates. It also
    * measures the time taken to generate the unique IDs.
    * @param - `idsLength` an optional parameter which specifies the number of
    * unique IDs to generate. If `idsLength` is not provided, it defaults to 100000.
    */
    runUUID(idsLength?: number): void
}

type TUUID<Prefix extends string> = TString<Prefix> | TNumber


/**
 * A wrapper function for the UniqueID class that provides a set of methods for generating and testing unique IDs
 * @description A function that generates unique IDs
 * @param options - An object that contains the type of unique ID to be generated, the prefix to be added to the unique ID and the length of the unique ID.
 ** Note: If the type of unique ID is "number", the prefix will be ignored and will return a number with the specified length
  * @example
  * const id = UUID().generate();
  * const id = UUID({ type: "number", length: 14 }).generate();
  * const id = UUID({ type: "string", prefix: "prefix", length: 10 }).generate();
 * @returns {Object} An object that contains the methods for generating unique IDs and testing the accuracy of the unique ID algorithm
 */
function UUID<Prefix extends string>(options: TUUIDOptions<Prefix> & { type: "number", prefix: Prefix }): TString<Prefix>
function UUID<Prefix extends string>(options: TUUIDOptions<Prefix> & { type: "number" }): TNumber
function UUID<Prefix extends string>(options: TUUIDOptions<Prefix> & { type: "string" }): TString<Prefix>
function UUID({ }: {}): TString<string>
function UUID(): TString<string>
function UUID<Prefix extends string>(options: TUUIDOptions<Prefix> & { prefix?: Prefix }): TString<Prefix>
function UUID<Prefix extends string>(options?: TUUIDOptions<Prefix>): TUUID<Prefix> {
    const uniqueID = new UniqueID(options?.prefix || "", options && options.type ? options.type : "string");
    return {
        /**
         * Generates a unique ID
         * @returns {string | number} A unique ID with the specified prefix and length
        */
        generate: () => uniqueID.generate(options?.length ?? 24) as any,
        /**
        * The test method tests the uniqueness of the unique ID algorithm by generating a large number of unique IDs and checking for duplicates
        * @returns {boolean} A boolean that indicates whether the list of generated unique IDs are unique or not
        */
        test: () => uniqueID.testUniqueID(),
        /**
            * The `runUUID` function generates a large number of unique IDs and checks for duplicates. It also
            * measures the time taken to generate the unique IDs.
            * @param - `idsLength` an optional parameter which specifies the number of
            * unique IDs to generate. If `idsLength` is not provided, it defaults to 100000.
        */
        runUUID: (idsLength?: number) => uniqueID.runUUID({ length: options?.length, idsLength: idsLength })
    }
}

export default UUID;